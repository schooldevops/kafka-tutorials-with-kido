# Kafka Topic Naming Conventions

- from : https://cnr.sh/essays/how-paint-bike-shed-kafka-topic-naming-conventions

- 카프카 토픽 이름에 대한 주제에 대해서 논의를 할 것이다. 
- 다양한 스키마 뿐만 아니라 몇가지 문제에 대해 입장을 취하고 내 추론을 설명하기로 결정했다. 
- 브러쉬를 꺼내서 그리고 자전거 보관소를 칠해보자. 

- Kafka 주제 명명 규칙에 대한 인터넷 지침은 놀랍게도 거의 없다. 
- 몇가지 드문 Stack Overflow질문과 몇가지 메일링 리스트 토론이 모두 Google의 첫번째 페이지에 나타난다. 
- 이 문제에 대한 의견은 매우 다양하다. 위 링크의 몇가지 제안 사항은 다음과 같다. 

```py
  <root name space>.<product>.<product specific hirerachy>
  <app type>.<app name>.<dataset name>.<stage of processing>
  <app type>.<dataset name>.<data>

```

## Convention types

- 다음은 이름 규칙의 2가지 타입이 존재한다. 하나는 구조이고 다른 하나는 의미이다. 
- 좋은 토픽 이름 규칙은 구조와 의미 둘다 정의되는 것이다. 

- 구조적인 컨벤션은 어떠한 종류의 구문문자를 이용할지, 포맷 형식은 어떻게 할지에 대한 내용이다. 
- 가장 기본적인 구조에 대한 컨벤션은 실제로 kafka 자체가 적용하는 것이다. 

```
Kafka 토픽에 대한 유용한 캐릭터들은 ASCII 알파벳, 숫자, '.', '_', '-' 을 사용하는 것이다.
```

- 이를 벗어날 수 없다. 
- 그러나 예를 들어 대시가 공백으로 사용되거나 모든 주제가 camelCase여야 한다고 말함으로써 더 세분화할 수 있다. 

- 의미론적인 컨벤션들은 토픽 이름에 어떠한 필드에 어떤 순서로 기술할지에 대한 내용이다. 

## 잠재적인 필드들

- 사람들은 그들이 생각하는 관습에서 꽤 창의적이라는 것이 밝혀졌다. 
- 명명 규칙에서 사용되거나 제안된 여러 필드는 다음과 같다. 
  - Product
    - 토픽과 관련된 제품의 이름이다. 
  - Schema name
    - 토픽내 메시지에 대한 스키마 이름
    - 일반적으로 Avro 스키마 이름이다. 
  - Namespace
    - org.foo.bar 와 같은 형태이다. 
    - 일반적으로 스키마 이름들로 연결된다. 
  - Type
    - 어떠한 토픽을 사용할지 여부
    - ETL, Queuing, tracking, user, data push, streaming 등등
  - Application name
    - 어플리케이션의 이름 혹은 서비스의 이름으로 메시지를 발생시킨다. 
    - 이것은 컨슈머 이름과 유사하다. 프로듀서 사이드는 예외이다. 
  - Dataset name
    - 토픽 컬렉션내에 포함되는 이름이다. 
    - 데이터베이스 이름과 유사하다. 
  - Processing stage
    - 처리 파이프라인의 스텝이다. 
    - 특별히 스트림 프로세싱에서 유용하다. 
    - 예를 들어: filtered, partitioned, joined 등등
  - Public/private
    - 주제가 내부 구현 세부 정보(예: Kafka의 __consumer_offets 주제) 인지 여부를 나타낸다. 
  - Security
    - 주제에 AuthN/AuthZ가 활성화되어 있는지 여부 
  - Consumer name
    - 컨슈머의 이름으로 이것은 토픽에서 데이터를 컨슈머 하는 이름이다. 
  - Partition key
    - 어떠한 토픽내에 필드의 이름으로 파티션된다. 
  - Partition counts
    - 토픽에 대한 파티션의 숫자
  - Version numbers
    - 이전 버젼과 호환되지 않는 변경이 이루어지거나 데이터 마이그레이션이 발생하는 경우와 같이 항목의 새 버젼을 나타내기 위해 증가할 수 있는 숫자이다. 
  - Owner/team name
    - 오너나 팀의 이름으로 토픽에 대한 책임을 진다. 

## 하지말아야할것

### 변경되는 것은 필드로 쓰지마라. 

- 가장 큰 조언으로 변경이 가능한 변경이 될수 있는 필드는 피하는 것이다. 
- 이것은 팀이름, 토픽 주인, 서비스이름, 제품이름, 컨슈머 이름 등과 같은 이름을 쓰지말자는 것이다. 
- 동적 필드를 피하는 이유는 주제의 이름을 바꾸는 것이 불가능하고 데이터를 새 주제로 마이그레이션 하는 것이 힘들 수 있기 때문이다. 
- 서비스가 디프리케이트 되거나 제거된다면, 예를 들어 서비스의 이름이 여전히 Kafka 토픽내 존재하게 된다. 

### 데이터가 다른 곳에서 사용될 수 있다면 쓰지마라. 

- 여기서의 논리는 다른 출처에서 정보를 얻을 수 있다면 그렇게 하는 것이 최선이라는 것이다. 
- 특히 다른 소스가 실제적으로 source of truth 가 된다. 
- 다음 주가지 공통적인 소스들이다. 
  - Schema registry
  - Kafka metadata
- 스키마 레디스트리는 주어진 주제에 대한 스키마에 대한 정보를 제공할 수 있다. 
- 이는 주제의 키와 값 모두에 해당된다. 
- 또한 이 정보에 대한 진실의 출처이기도 하다. 

- 카프카 브로커는 파티션 수, 복제 번호, 보안 정보 등을 포함하는 주제 메타데이터 정보를 제공한다. 
- 다시 말하지만 Kafka는 이 정보에 대한 진실의 출처이다. 

### 토픽 이름을 컨슈머와 프로듀서를 연결하지 마라. 

- 토픽에 둘 이상의 소비자가 있을 가능성이 높으며, 토픽에 메시지를 보내는 사람이 시간이 지남에 따라 변경될 수 있다. 
- 위의 동적 필드 규칙을 위반하기 때문에 주제 이름에 이들 중 하나를 포함하는 것은 이치에 맞지 않다.

## 다음은 수행하라. 

- 그럼 어떻게 해야 할까요? 기본적이고 유연한 컨벤션으로 성공했다. 

```js
<message type>.<dataset name>.<data name>
```

- 다음은 유용한 메시지 타입 값은 정의할 조직에 달려있다. 
- 일반적인 타입들은 다음과 같다. 
  - logging: 로깅을 위한 데이터
  - queuing: 전통적인 큐 케이스
  - tracking: 사용자 클릭, 페이지 뷰, 뷰 등과 같은 트래킹을 위한 이벤트 
  - etl/db: ETL과 CDC 사용 케이스로 데이터베이스 피드와 같은 것
  - streaming: 스트림 프로세싱 파이프라인에 의해서 생성된 중간 토픽
  - push: 오프라인 환경에서 온라인 환경으로 푸시되는 데이터를 위한 타입
  - user: 사용자 특정 데이터, 스크래치와 테스트 토픽등 

- 데이터 세트 이름은 기존 RDBMS 시스템의 데이터베이스 이름과 유사하다. 
- 토픽을 함께 그룹화 하는 카테고리로 사용된다. 

- 데이터 이름 필드는 기존 RDBMS 시스템의 테이블 이름과 유사하지만 개발자가 데이터 세트 네임스페이스 내에서 자체 게층 구조를 적용하려는 경우 추가 점 표기법을 포함하는 것이 좋다. 

- 이 규칙의 매력은 전통적인 RDBMS 스타일과 유사하며 개발자가 이해하기 쉽다. 
- 누군가가 주제의 이름을 물어볼 때 RDBMS에 있는 데이터베이스/테이블의 이름을 물어보고 데이터 세트/데이터 필드로 제안할 수 있다. 

- 그리고 확장도 가능하다. 
- 만약 개발자나 조직이 자신이 가진 계층 구조를 적용하려고 할때 자신들의 특정 유즈케이스 혹은 메시지 타입과 일치한다. 
- 이들은 추가적인 점 표식으로 필드가 데이터이름 섹션에 추가될 것이다. 

- 구조에 관해서는 snake_case 를 사용하는 것이 좋다. camelCase, UpperCamelCase 또는 lisp-case는 아니다.)

## 규칙 시행

- 규칙을 시행하기 위한 가장 명확한 방법은 auto.create.topics.enable 를 비활성화 하고, 누가 토픽을 생성할 수 있는지 지정하는 것이다. 
- 사용자가 주제 생성의 일부로 다양한 필드를 정의하도록 하는 자동화된 주제 생성 프로세스가 선호되지만 주제를 생성하는 사람은 규칙을 적용할 책임이 있다. 

- 만약 사용자들이 자신의 토픽을 생성하는 것을 허용한다면 토픽이 규칙을 준수하는지 여부를 모니터링 하는 스크립트는 위반이 이미 발생한 후에 적어도 경고를 발생 시킨다. 
- 불행하게도 이때에는 너무 늦은 것이다. 

